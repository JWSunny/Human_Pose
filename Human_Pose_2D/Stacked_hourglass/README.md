数据集描述：【https://www.cnblogs.com/caffeaoto/p/7793994.html】
    1.MPII数据集，主要是人体的骨骼点数据集，该数据集包含人体的16个骨骼点坐标；
    2.coco数据集，主要包含人体的17个骨骼点坐标；


方法说明：
    （1）stacked hourglass网络

    全卷积网络； 多尺度的特征；
    捕捉图片的空间特征； 中间监督；

    1.在经典数据集MPII上，曾是MPII姿态分析的冠军，主要模块就是它的残差模块，一个支路
    先进行1*1下采样，然后3*3卷积操作，最后升采样，这样做的好处：能降低计算量，同时能集中
    处理主要的特征； 另一个分支，就是直接进行输入到输出的1*1卷积操作，两个分支叠加，采用残差
    的思想，在计算高层语义特征的同时，叠加原有层路特征；

    2.网络模型的实现最终是 2级网络，每级网络中是一个 4阶的hourglass；为了防止梯度消失的问题，
    也为了能更好的更新网络参数，每个hourglass都要添加loss，最终是8个loss一起监督，其实就是网络
    中，除了最后的特征图计算损失，中间的中级热图也会参与损失loss的计算

    3.每个堆叠沙漏网络，利用不同的尺度信息获取人体的不同部分的信息，不同尺度的特征图从而进行
    不同部位关节点的定位；hourglass网络中，最终要的组成部分就是 残差结构，组合原有层和高层的特征；

    4.最后回归的是 16*64*64的卷积特征图，每层特征图上的峰值，特征图中都是概率值，表示的是每个点是
    关节点的概率，每层特征图中的峰值就是该层中最可能存在的骨骼点位置；

    5.关于损失，其实把关节点的定位当做回归问题来解决，求的其实是预测关节点和真实关节点的L2距离损失；


主要实现：
    1.之前使用tensorflow和pytorch进行了hourglass的实现，主要使用2级网络，每级网络使用4阶的hourglass；
    主要是在hourglass网络上进行姿态估计，这边网络的输入是256*256的方图，输出是64*64*n_landmarks的热图；

    2.PCKh其实是评判指标，正确估计关节点的比例； 这边其实是预测关节点坐标与真实关节点坐标，相比于头部
    长度*0.6，就你行归一化操作，比例小于一个固定阈值的则认为预测正确；【阈值其实是0-0.5值选择，参数最优选择】



移动端的实现：

    1.为了能更好的进行人体的姿态估计，加入了人体检测检测，具体的操作：
    从coco和voc数据中，挑选出了包含人体的数据，利用mobilenet-ssd算法，训练出一个人体检测模型；【mAP在0.85左右】

    2.在移动端，由于内存的限制和时间的考虑，在训练移动端模型的时候，图片的尺寸调整为 192*192，输出是96*96的尺寸；
    同样使用的是stacked hourglass网络；


为了加快在移动端的的推理，后续使用的是 小米的移动框架 MACE；

    框架：https://github.com/XiaoMi/mace
    已有的模型文件：https://github.com/XiaoMi/mace-models

    1.主要思想就是基于model.py，训练得到我么的 model.pb文件，再将model.pb文件部署到model.yml文件中，之后通过
    convert.py编译转换将yml文件转成库文件，在移动端调用这些库文件就可以；

    https://www.cnblogs.com/missidiot/p/9480033.html系列文章进行介绍：
    2.安装必要的基础环境，同时MACE提供相关依赖项的docker镜像，可以通过镜像来构建完成，然后进行编译工作；

    3.准备训练好的模型文件，并利用图像转换工具，进行模型的优化推理；
    https://github.com/tensorflow/tensorflow/blob/master/tensorflow/tools/graph_transforms/README.md
    主要就是想优化在移动端上的推理过程，删除未调用的节点 和 一些乘法计算；

    4.创建部署文件，因为 MACE 需要读取yaml文件，所以需要根据优化的模型pb文件，创建yaml部署文件；

    5.https://github.com/XiaoMi/mace/tree/master/examples/android
    原始的 MACE 自带的Android实例，主要是通过修改官方实例，进行相关模型及文件的修改；
